name: Deploy to AWS App Runner

on:
  push:
    branches: [main]
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  pull_request:
    branches: [main]

env:
  AWS_REGION: ap-northeast-1
  APP_RUNNER_SERVICE_NAME: go-s3-uploader-service
  ECR_REGISTRY: 925867211284.dkr.ecr.ap-northeast-1.amazonaws.com
  ECR_REPOSITORY: go-s3-uploader
  APP_RUNNER_ACCESS_ROLE_ARN: arn:aws:iam::925867211284:role/AppRunnerECRAccessRole

permissions:
  id-token: write   # Required for OIDC
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache-dependency-path: |
            app-server/go.sum
            auth-server/go.sum
            shared/go.sum

      - name: Run tests
        run: |
          echo "ğŸ§ª Testing app-server module..."
          cd app-server
          go mod tidy
          go test ./...
          
          echo "ğŸ§ª Testing auth-server module..."
          cd ../auth-server
          go mod tidy
          go test ./...
          
          echo "âœ… All tests passed!"

      - name: Build application
        run: |
          echo "ğŸ”¨ Building app-server..."
          cd app-server
          go build -o main .
          
          echo "ğŸ”¨ Building auth-server..."
          cd ../auth-server
          go build -o main .
          
          echo "âœ… All builds completed!"

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract tag name
        id: get_tag
        if: startsWith(github.ref, 'refs/tags/v')
        run: echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Validate tag format
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          TAG="${{ steps.get_tag.outputs.TAG }}"
          REGEX="^v([0-9]{1,2})\.([0-9]{1,2})\.([0-9]{1,2})$"
          if [[ $TAG =~ $REGEX ]]; then
            echo "âœ… Tag '${TAG}' matches the required format."
          else
            echo "âŒ ERROR: Tag '${TAG}' does not match the required format 'vX.X.X' (e.g., v1.0.0)."
            exit 1
          fi

      # æ–¹æ¡ˆ1: ä½¿ç”¨ OIDC (æ¨è) - éœ€è¦å…ˆé…ç½® AWS OIDC æä¾›å•†
      # - name: Configure AWS credentials (OIDC)
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      #     role-session-name: GitHubActionsSession
      #     aws-region: ${{ env.AWS_REGION }}

      # æ–¹æ¡ˆ2: ä½¿ç”¨ Secrets (å½“å‰ä½¿ç”¨)
      - name: Configure AWS credentials (Secrets)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker image tag
        id: image-tag
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            TAG="${{ steps.get_tag.outputs.TAG }}"
          else
            TAG="latest"
          fi
          echo "IMAGE_TAG=$TAG" >> $GITHUB_OUTPUT
          echo "FULL_IMAGE_URI=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$TAG" >> $GITHUB_OUTPUT

      - name: Build, tag, and push image to Amazon ECR
        run: |
          echo "ğŸ³ Building Docker image..."
          docker build -t ${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.IMAGE_TAG }} .
          docker tag ${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.IMAGE_TAG }} ${{ steps.image-tag.outputs.FULL_IMAGE_URI }}
          
          echo "ğŸ“¤ Pushing image to ECR..."
          docker push ${{ steps.image-tag.outputs.FULL_IMAGE_URI }}
          
          echo "âœ… Image pushed successfully: ${{ steps.image-tag.outputs.FULL_IMAGE_URI }}"

      - name: Deploy to App Runner
        run: |
          # å°è¯•æ›´æ–°ç°æœ‰æœåŠ¡ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°æœåŠ¡
          echo "ğŸš€ Deploying to AWS App Runner..."
          
          # æ£€æŸ¥æœåŠ¡æ˜¯å¦å­˜åœ¨
          if aws apprunner describe-service --service-arn "arn:aws:apprunner:${{ env.AWS_REGION }}:925867211284:service/${{ env.APP_RUNNER_SERVICE_NAME }}" 2>/dev/null; then
            echo "âœ… Service exists, updating with new image..."
            SERVICE_ARN="arn:aws:apprunner:${{ env.AWS_REGION }}:925867211284:service/${{ env.APP_RUNNER_SERVICE_NAME }}"
            
            # å…ˆç­‰å¾…æœåŠ¡å¤„äºå¯æ“ä½œçŠ¶æ€
            echo "â³ Waiting for service to be in a stable state..."
            for i in {1..30}; do
              STATUS=$(aws apprunner describe-service --service-arn $SERVICE_ARN --query 'Service.Status' --output text)
              echo "Service status: $STATUS (attempt $i/30)"
              if [ "$STATUS" = "RUNNING" ]; then
                echo "âœ… Service is running, updating with new image..."
                
                # æ›´æ–°æœåŠ¡é…ç½®
                echo '{
                  "ServiceArn": "'"$SERVICE_ARN"'",
                  "SourceConfiguration": {
                    "AutoDeploymentsEnabled": false,
                    "ImageRepository": {
                      "ImageIdentifier": "'"${{ steps.image-tag.outputs.FULL_IMAGE_URI }}"'",
                      "ImageConfiguration": {
                        "Port": "8080",
                        "RuntimeEnvironmentVariables": {
                          "PORT": "8080",
                          "AWS_REGION": "${{ env.AWS_REGION }}",
                          "S3_BUCKET_NAME": "raymond-go-s3-uploader-dev-2025"
                        }
                      },
                      "ImageRepositoryType": "ECR"
                    },
                    "AccessRoleArn": "${{ env.APP_RUNNER_ACCESS_ROLE_ARN }}"
                  }
                }' > update-config.json
                
                aws apprunner update-service --cli-input-json file://update-config.json
                break
              elif [ "$STATUS" = "CREATE_FAILED" ] || [ "$STATUS" = "DELETE_FAILED" ]; then
                echo "âŒ Service failed with status: $STATUS"
                exit 1
              fi
              sleep 10
            done
          else
            echo "ğŸ†• Service does not exist, creating new service..."
            
            # åˆ›å»ºæœåŠ¡é…ç½®JSON
            echo '{
              "ServiceName": "'"${{ env.APP_RUNNER_SERVICE_NAME }}"'",
              "SourceConfiguration": {
                "AutoDeploymentsEnabled": false,
                "ImageRepository": {
                  "ImageIdentifier": "'"${{ steps.image-tag.outputs.FULL_IMAGE_URI }}"'",
                  "ImageConfiguration": {
                    "Port": "8080",
                    "RuntimeEnvironmentVariables": {
                      "PORT": "8080",
                      "AWS_REGION": "${{ env.AWS_REGION }}",
                      "S3_BUCKET_NAME": "raymond-go-s3-uploader-dev-2025"
                    }
                  },
                  "ImageRepositoryType": "ECR"
                },
                "AccessRoleArn": "${{ env.APP_RUNNER_ACCESS_ROLE_ARN }}"
              },
              "InstanceConfiguration": {
                "Cpu": "0.25 vCPU",
                "Memory": "0.5 GB"
              },
              "HealthCheckConfiguration": {
                "Protocol": "HTTP",
                "Path": "/health",
                "Interval": 20,
                "Timeout": 5,
                "HealthyThreshold": 2,
                "UnhealthyThreshold": 3
              }
            }' > service-config.json
            
            # åˆ›å»ºæœåŠ¡
            CREATE_RESULT=$(aws apprunner create-service --cli-input-json file://service-config.json)
            SERVICE_ARN=$(echo $CREATE_RESULT | jq -r '.Service.ServiceArn')
            echo "SERVICE_ARN=$SERVICE_ARN" >> $GITHUB_ENV
          fi
          
          # ç­‰å¾…éƒ¨ç½²å®Œæˆ
          echo "â³ Waiting for service to be ready..."
          # ç­‰å¾…æœåŠ¡çŠ¶æ€å˜ä¸º RUNNINGï¼Œæœ€å¤šç­‰å¾…10åˆ†é’Ÿ
          for i in {1..60}; do
            STATUS=$(aws apprunner describe-service --service-arn $SERVICE_ARN --query 'Service.Status' --output text)
            echo "Service status: $STATUS (attempt $i/60)"
            if [ "$STATUS" = "RUNNING" ]; then
              echo "âœ… Service is now running!"
              break
            elif [ "$STATUS" = "CREATE_FAILED" ] || [ "$STATUS" = "DELETE_FAILED" ]; then
              echo "âŒ Service failed with status: $STATUS"
              exit 1
            fi
            sleep 10
          done
          
          # è·å–æœåŠ¡URL
          echo "ğŸŒ Getting service URL..."
          SERVICE_URL=$(aws apprunner describe-service --service-arn $SERVICE_ARN --query 'Service.ServiceUrl' --output text)
          echo "âœ… Service deployed successfully at: https://$SERVICE_URL"
